<snippet>
	<content><![CDATA[
struct NTT {
    int mod, root, root_1, root_pw;

    // mod = c * (2^k) + 1, g is some generator of mod
    NTT(int c, int g, int k) {
        root_pw = 1 << k;
        mod = c * root_pw + 1;
        root = pwr(g, c);
        root_1 = pwr(root, mod - 2);
    }

    void transform(vector<int> & a, bool invert) {
        int n = (int) a.size();
        assert ((n & (n - 1)) == 0); // power of 2
        assert (n <= root_pw);
     
        for (int i=1, j=0; i<n; ++i) {
            int bit = n >> 1;
            for (; j>=bit; bit>>=1)
                j -= bit;
            j += bit;
            if (i < j)
                swap (a[i], a[j]);
        }
     
        for (int len=2; len<=n; len<<=1) {
            int wlen = invert ? root_1 : root;
            for (int i=len; i<root_pw; i<<=1)
                wlen = int (wlen * 1ll * wlen % mod);
            for (int i=0; i<n; i+=len) {
                int w = 1;
                for (int j=0; j<len/2; ++j) {
                    int u = a[i+j],  v = int (a[i+j+len/2] * 1ll * w % mod);
                    a[i+j] = u+v < mod ? u+v : u+v-mod;
                    a[i+j+len/2] = u-v >= 0 ? u-v : u-v+mod;
                    w = int (w * 1ll * wlen % mod);
                }
            }
        }
        if (invert) {
            int nrev = pwr(n, mod - 2);
            for (int i=0; i<n; ++i)
                a[i] = int (a[i] * 1ll * nrev % mod);
        }

    }

    long long pwr(long long a, long long b) {
        long long ret = 1;
        while (b > 0) {
            if (b & 1) {
                ret = ret * a % mod;
            }
            b >>= 1;
            a = a * a % mod;
        }
        return ret;
    }
};

struct PolynomialUtility {
    NTT *ntt;
    PolynomialUtility(NTT *ntt) : ntt(ntt) {}

    /**
     * Let n be the smallest power of 2 which is greater than or equal to "terms".
     * Returns the first n coefficients of x in A * B
     * 
     * if terms == -1, it will assume the worst and make n as big as required.
     */
    vector<int> multiply(const vector<int> &A, const vector<int> &B, int terms) {
        if (terms == -1) {
            terms = A.size() + B.size();   
        }
        int n = 1 << (int)ceil(log2(terms));
        assert (n <= ntt->root_pw);
        vector<int> FA(A.begin(), A.end());
        vector<int> FB(B.begin(), B.end());
        FA.resize(n);
        FB.resize(n);
        ntt->transform(FA, false);
        ntt->transform(FB, false);
        for (int i = 0; i < FA.size(); ++i) {
            FA[i] = (FA[i] * 1ll * FB[i]) % ntt->mod;
        }
        ntt->transform(FA, true);
        return FA;
    }

    vector<int> multiplyTransformed(const vector<int> &FA, const vector<int> &FB) {
        int n = FA.size();
        assert ((n & (n - 1)) == 0); // transform must be power of 2
        assert (n <= ntt->root_pw);
        vector<int> FR(n);
        for (int i = 0; i < FA.size(); ++i) {
            FR[i] = (FA[i] * 1ll * FB[i]) % ntt->mod;
        }
        ntt->transform(FR, true);
        return FR;
    }

    /**
     * Let n be the smallest power of 2 which is greater than or equal to "terms".
     * Returns the first n coefficients of x in a^b
     * 
     * if terms == -1, it will assume the worst and make n as big as required.
     */
    vector<int> pwr(const vector<int> &A, long long b, int terms = -1) {
        if (terms == -1) {
            terms = A.size() * b;
        }
        int n = 1 << (int)ceil(log2(terms));
        assert (n <= ntt->root_pw);
        vector<int> FA(A.begin(), A.end());
        FA.resize(n);
        ntt->transform(FA, false);
        for (int i = 0; i < FA.size(); ++i) {
            FA[i] = ntt->pwr(FA[i], b);
        }
        ntt->transform(FA, true);
        return FA;
    }

    vector<int> getTransform(const vector<int> &A, bool invert) {
        int n = 1 << (int)ceil(log2(A.size()));
        vector<int> FA(A.begin(), A.end());
        FA.resize(n);
        ntt->transform(FA, invert);
        return FA;
    }

    void scale(vector<int> &A, int b) {
        for (int i = 0; i < A.size(); ++i) {
            A[i] = A[i] * 1ll * b % ntt->mod; 
        }
    }
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>importNTT</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
